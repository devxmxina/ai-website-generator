
# main.py
import json
import streamlit as st
from app.layout import show_form
from utils.ai_generator import generate_website_data
from app.i18n import get_translator
import google.generativeai as genai # Import for API configuration

# Set page configuration (title, layout)
st.set_page_config(page_title="AI Website Generator", layout="wide")

# --- Session State Initialization ---
# Initialize session state variables if they don't exist.
# This helps maintain state across reruns of the Streamlit app.

# Flag to track if user inputs have been submitted and processed
if 'user_inputs_submitted' not in st.session_state:
    st.session_state.user_inputs_submitted = False
# Stores the raw JSON string generated by the AI
if 'generated_json_string' not in st.session_state:
    st.session_state.generated_json_string = None
# Flag to track if the Gemini API key has been successfully configured
if 'api_key_configured' not in st.session_state:
    st.session_state.api_key_configured = False

# --- Sidebar ---
# Elements placed in the sidebar are typically for settings, navigation, or less frequently used controls.
with st.sidebar:
    # Sidebar title (using a fixed English string for "Settings" for simplicity, or it could be translated too)
    st.title("‚öôÔ∏è " + get_translator("English")("Settings"))

    # Language selection dropdown
    selected_language = st.selectbox(
        "üåç Language / –Ø–∑—ã–∫ / Limba", # Label for the language selector
        ["English", "–†—É—Å—Å–∫–∏–π", "Rom√¢nƒÉ"], # Available languages
        key="lang_select" # Unique key for this widget
    )
    # Get the translator function for the selected language
    _ = get_translator(selected_language)

    # API Key input section
    st.subheader(_("API Key")) # Translated subheader
    api_key_input = st.text_input(
        _("Enter your Gemini API key"), # Translated label for the text input
        type="password", # Mask the input for security
        key="api_key_input", # Unique key
        help=_("Your API key is used to communicate with the Gemini AI model. It is not stored.") # Translated help text
    )

    # Button to configure the API key
    if st.button(_("Configure API Key"), key="configure_api_button"):
        if api_key_input: # Check if an API key was entered
            try:
                # Configure the Gemini API with the provided key
                genai.configure(api_key=api_key_input)
                # Optional: A simple test call to verify the API key (currently commented out)
                # model = genai.GenerativeModel("gemini-1.5-flash")
                # model.generate_content("test") # If this fails, the key is likely invalid
                st.session_state.api_key_configured = True # Set configuration status to true
                st.session_state.active_api_key = api_key_input # Store the active key (optional, if needed elsewhere)
                st.success(_("API Key configured successfully!")) # Display success message
            except Exception as e:
                # If configuration fails, update status and show an error
                st.session_state.api_key_configured = False
                st.error(_(f"Failed to configure API Key: Please check your key. Error: {e}"))
        else:
            # If no API key was entered, show a warning
            st.warning(_("Please enter an API key."))

    # Display API key status
    if st.session_state.api_key_configured:
        st.success("üîë " + _("API Key is active.")) # Show success status
    else:
        st.warning("‚ùó " + _("API Key not configured.")) # Show warning status

    # Download JSON button (appears only if JSON has been generated)
    if st.session_state.generated_json_string:
        try:
            # Attempt to create a filename based on the company name from the JSON
            json_data_for_filename = json.loads(st.session_state.generated_json_string)
            # Safely get company_name, replace spaces with underscores, convert to lowercase
            company_name_for_file = json_data_for_filename.get("project_overview", {}).get("company_name", "website_ai_generated").replace(" ", "_").lower()
            file_name = f"{company_name_for_file}_structure.json"
        except:
            # Fallback filename if company_name cannot be parsed
            file_name = "website_ai_generated_structure.json"

        # Streamlit's download button widget
        st.download_button(
            label=_("Download Website JSON"), # Translated button label
            data=st.session_state.generated_json_string, # The data to download (the JSON string)
            file_name=file_name, # Suggested filename for the download
            mime="application/json", # MIME type for JSON files
            key="download_json_button" # Unique key
        )

# --- Main Page Content ---
# Title for the main page
st.title("üåê " + _("AI Website Generator"))
# Introductory markdown text
st.markdown(_("Fill in the details below to generate a website structure using AI."))

# Check if API key is configured before showing the form and generation button
if not st.session_state.api_key_configured:
    st.info(_("Please configure your Gemini API key in the sidebar to proceed."))
else:
    # Display the input form (defined in app/layout.py)
    # The show_form function now uses the globally available translator '_'
    user_inputs = show_form(_)

    if user_inputs: # Check if the form returned valid data
        # Button to trigger website structure generation
        if st.button(_("Generate Website Structure"), key="generate_button", type="primary"):
            with st.spinner(_("ü§ñ AI is thinking... Please wait.")): # Show a spinner during generation
                # The API key is already configured globally
                # Call the AI generation function, passing user inputs and the translator
                raw_result_json_string = generate_website_data(user_inputs, _)

                # The generate_website_data function should now return either a valid JSON string
                # or an error message (prefixed with "‚ùå") from the translator.
                if raw_result_json_string.startswith("‚ùå"): # Check if the function returned an error
                    st.error(raw_result_json_string) # Display the error message
                    st.session_state.generated_json_string = None # Reset generated JSON
                    st.session_state.user_inputs_submitted = False # Reset submission status
                else:
                    try:
                        # Attempt to parse the JSON string to ensure it's valid
                        # (This is an extra check; generate_website_data should ideally ensure validity)
                        parsed_result = json.loads(raw_result_json_string)
                        st.session_state.generated_json_string = raw_result_json_string # Store the valid JSON string
                        st.session_state.user_inputs_submitted = True # Set submission status to true
                        st.success(_("üéâ Website structure generated successfully!")) # Display success message
                    except json.JSONDecodeError:
                        # If JSON parsing fails here, it's a critical error
                        st.error(_("Critical error: AI response was not valid JSON, though it passed initial checks. This should not happen."))
                        st.code(raw_result_json_string, language="text") # Show the malformed string
                        st.session_state.generated_json_string = None # Reset generated JSON
                        st.session_state.user_inputs_submitted = False # Reset submission status
        else:
            pass # Do nothing if the button is not pressed

# Display the generated result if available
if st.session_state.user_inputs_submitted and st.session_state.generated_json_string:
    st.markdown("---") # Horizontal rule for separation
    st.subheader(_("üëÅÔ∏è‚Äçüó®Ô∏è Generated Website Structure (JSON Preview)")) # Subheader for the preview

    # Display the JSON data
    try:
        # Use st.json for a nicely formatted, interactive JSON display
        st.json(json.loads(st.session_state.generated_json_string), expanded=True)
    except:
        # Fallback: if st.json fails (e.g., string is somehow still invalid), show as raw code
        st.code(st.session_state.generated_json_string, language="json")


    # Example of displaying parts of the JSON in a more structured way (adapt to your JSON structure)
    try:
        # Parse the JSON string into a Python dictionary
        data = json.loads(st.session_state.generated_json_string)

        # Display Project Overview details
        if "project_overview" in data:
            st.markdown("---")
            st.subheader(_("Project Overview Details"))
            overview = data["project_overview"]
            st.markdown(f"**{_('Company Name')}:** {overview.get('company_name')}")
            st.markdown(f"**{_('Industry')}:** {overview.get('industry')}")
            if overview.get('ai_generated_project_summary'):
                st.markdown(f"**{_('AI Summary')}:** {overview.get('ai_generated_project_summary')}")
            st.markdown(f"**{_('Suggested Tagline')}:** {overview.get('suggested_tagline')}")
            st.markdown(f"**{_('Logo Concept')}:** {overview.get('logo_concept_suggestion')}")

        # Display Global Style suggestions
        if "global_style" in data:
            st.markdown("---")
            st.subheader(_("üé® Suggested Global Styles"))
            style = data["global_style"]
            if "color_palette" in style:
                st.markdown(f"**{_('Color Palette')}:**")
                colors = style["color_palette"]
                # Display colors in columns for better layout
                cols = st.columns(len(colors) if len(colors) <= 5 else 5)
                col_idx = 0
                for name, hex_code in colors.items():
                    with cols[col_idx % len(cols)]:
                        # Display color name, hex code, and a color swatch
                        st.markdown(f"`{name}`: `{hex_code}` <span style='display:inline-block; width: 20px; height:20px; background-color:{hex_code}; border: 1px solid #ccc; border-radius: 3px;'></span>", unsafe_allow_html=True)
                    col_idx +=1
            # TODO: You can add more detailed display for fonts, buttons, etc.

        # Display Page Structure Overview
        if "pages" in data:
            st.markdown("---")
            st.subheader(_("üìÑ Page Structure Overview"))
            for page in data["pages"]:
                # Use an expander for each page to keep the UI clean
                expander_title = f"{_('Page')}: {page.get('page_title', page.get('page_id', 'N/A'))}"
                with st.expander(expander_title):
                    st.markdown(f"**{_('Page ID')}:** `{page.get('page_id')}`")
                    if "sections" in page:
                        for i, section in enumerate(page["sections"]):
                            st.markdown(f"**{_('Section')} {i+1}: {section.get('section_type', 'N/A')}** (`{section.get('section_id')}`)")
                            st.markdown(f"> *{_('Headline')}:* {section.get('content', {}).get('headline', 'N/A')}")
                            if section.get('content', {}).get('subheadline'):
                                st.markdown(f"> *{_('Subheadline')}:* {section.get('content', {}).get('subheadline')}")
                            # TODO: You can add more details like layout, body text preview, etc.
                            # st.markdown(f"> *Layout:* {section.get('layout_suggestion', 'N/A')}")
                            # st.markdown(f"> *Body:* {section.get('content', {}).get('body_text', 'N/A')[:100]}...") # Preview first 100 chars
    except Exception as e:
        # Catch any errors during the detailed display rendering
        st.error(_(f"Error displaying detailed breakdown: {e}"))